## 3.9 BACKEND API DEVELOPMENT

### 3.9.1 Laravel Framework and PHP Development

The Verdex backend API was developed using Laravel framework version 11.0 with PHP 8.2+, providing a robust foundation for the RESTful API architecture. The choice of Laravel was driven by its comprehensive ecosystem, built-in security features, and excellent support for API development.

#### 3.9.1.1 Laravel Architecture and MVC Pattern

The backend follows Laravel's Model-View-Controller (MVC) architecture with API-specific adaptations:

**Architecture Components:**
- **Models**: Eloquent ORM for database interactions
- **Controllers**: API controllers handling HTTP requests
- **Resources**: JSON response formatting
- **Middleware**: Request processing and authentication
- **Routes**: RESTful API endpoint definitions

**Project Structure:**
```
backend/
├── app/
│   ├── Http/Controllers/Api/     # API controllers
│   ├── Http/Resources/           # JSON response resources
│   ├── Http/Requests/            # Form request validation
│   ├── Http/Middleware/          # Custom middleware
│   ├── Models/                   # Eloquent models
│   └── Notifications/            # Email notifications
├── routes/
│   └── api.php                   # API route definitions
└── config/                       # Configuration files
```

#### 3.9.1.2 PHP 8.2+ Features and Best Practices

The application leverages modern PHP features for enhanced performance and type safety:

**PHP 8.2+ Features:**
- **Type Declarations**: Strict typing for method parameters and return types
- **Named Arguments**: Improved function call readability
- **Constructor Property Promotion**: Simplified class definitions
- **Match Expressions**: Enhanced switch statement functionality
- **Nullsafe Operator**: Safe property access on potentially null objects

**Code Example:**
```php
class PlantController extends Controller
{
    public function store(StorePlantRequest $request): PlantResource
    {
        $plantData = $request->only([
            'scientific_name', 
            'plant_category_id', 
            'family', 
            'genus', 
            'species', 
            'toxicity_level'
        ]);
        
        $plant = Plant::create($plantData);
        return new PlantResource($plant);
    }
}
```

#### 3.9.1.3 Laravel Ecosystem and Package Management

The application utilizes Laravel's ecosystem and third-party packages:

**Core Laravel Packages:**
- **Laravel Sanctum**: API authentication and token management
- **Laravel UI**: Basic authentication scaffolding
- **Laravel Tinker**: Interactive REPL for development

**Third-Party Packages:**
- **Spatie Laravel Permission**: Role-based access control
- **Spatie Laravel Activity Log**: User activity tracking
- **Spatie Laravel Media Library**: File upload and management
- **Browser Sessions**: Multi-device session management

### 3.9.2 RESTful API Design and Implementation

#### 3.9.2.1 API Endpoint Design and Routing

The API implements RESTful principles with comprehensive endpoint coverage:

**Authentication Endpoints:**
```php
Route::post('/login', [AuthController::class, 'login']);
Route::post('/register', [AuthController::class, 'register']);
Route::post('/forget-password', [ForgotPasswordController::class, 'sendResetLinkEmail']);
Route::post('/reset-password', [ResetPasswordController::class, 'reset']);
Route::post('/send-temp-password', [ForgotPasswordController::class, 'sendTempPassword']);
```

**Protected Resource Endpoints:**
```php
Route::group(['middleware' => 'auth:sanctum'], function() {
    Route::post('/logout', [AuthController::class, 'logout']);
    Route::apiResource('users', UserController::class);
    Route::apiResource('plants', PlantController::class);
    Route::apiResource('categories', CategoryController::class);
    Route::apiResource('roles', RoleController::class);
    Route::apiResource('permissions', PermissionController::class);
    Route::post('feedback', [FeedbackController::class, 'store']);
});
```

**Public Plant Endpoints:**
```php
Route::get('plants/app/all', [PlantController::class, 'getAllForApp']);
Route::get('plants/app/search', [PlantController::class, 'searchForApp']);
```

#### 3.9.2.2 Request/Response Format and Standards

The API implements consistent request/response patterns:

**Standard Response Format:**
```php
class Controller extends BaseController
{
    protected function successResponse($data, $message = null, $code = 200)
    {
        return response()->json([
            'success' => true,
            'message' => $message,
            'data' => $data
        ], $code);
    }

    protected function errorResponse($message = null, $code)
    {
        return response()->json([
            'success' => false,
            'message' => $message,
            'data' => null
        ], $code);
    }
}
```

**Resource Transformation:**
```php
class PlantResource extends JsonResource
{
    public function toArray($request)
    {
        return [
            'id' => $this->id,
            'scientific_name' => $this->scientific_name,
            'plant_category' => $this->plantCategory,
            'family' => $this->family,
            'genus' => $this->genus,
            'species' => $this->species,
            'toxicity_level' => $this->toxicity_level,
            'image_urls' => json_decode($this->image_urls) ?? [],
            'translations' => PlantTranslationResource::collection($this->translations),
            'created_at' => $this->created_at->toDateString(),
            'updated_at' => $this->updated_at->toDateString(),
        ];
    }
}
```

#### 3.9.2.3 API Versioning Strategy

The API implements versioning through URL structure and content negotiation:

**Versioning Approach:**
- URL-based versioning for major changes
- Content negotiation for minor updates
- Backward compatibility maintenance
- Deprecation notices for old endpoints

**Implementation:**
```php
// Current version endpoints
Route::prefix('v1')->group(function () {
    Route::apiResource('plants', PlantController::class);
});

// Future version endpoints
Route::prefix('v2')->group(function () {
    Route::apiResource('plants', PlantControllerV2::class);
});
```

#### 3.9.2.4 API Documentation and OpenAPI Specification

The API includes comprehensive documentation:

**Documentation Features:**
- OpenAPI/Swagger specification generation
- Interactive API documentation
- Request/response examples
- Authentication documentation
- Error code documentation

### 3.9.3 Authentication and Authorization System

#### 3.9.3.1 Laravel Sanctum Implementation

The application uses Laravel Sanctum for API authentication:

**Authentication Features:**
- Token-based authentication
- Stateless API access
- Token expiration management
- Multi-device support
- Secure token storage

**Implementation:**
```php
class AuthController extends Controller
{
    public function login(Request $request)
    {
        $request->validate([
            'login' => 'required|string',
            'password' => 'required',
        ]);

        $login = $request->login;
        $field = filter_var($login, FILTER_VALIDATE_EMAIL) ? 'email' : 'username';
        $user = User::where($field, $login)->first();

        if (!$user || !Hash::check($request->password, $user->password)) {
            throw ValidationException::withMessages([
                'login' => ['The provided credentials are not correct.'],
            ]);
        }

        $token = $user->createToken('auth-token')->plainTextToken;

        return response()->json([
            'access_token' => $token,
            'token_type' => 'Bearer',
            'user' => $user,
        ]);
    }
}
```

#### 3.9.3.2 JWT Token Management and Security

The application implements secure token management:

**Security Features:**
- Token expiration and refresh mechanisms
- Secure token storage in database
- Token revocation on logout
- Rate limiting on authentication endpoints
- CSRF protection for web routes

**Token Management:**
```php
public function logout(Request $request)
{
    $request->user()->currentAccessToken()->delete();
    return response()->json(['message' => 'Logged out successfully']);
}
```

#### 3.9.3.3 Role-Based Access Control (RBAC)

The application implements comprehensive RBAC using Spatie Laravel Permission:

**RBAC Features:**
- Role and permission management
- Hierarchical permission structure
- Dynamic permission assignment
- Policy-based authorization
- Activity logging for security events

**Implementation:**
```php
class PermissionController extends Controller
{
    public function store(StorePermissionRequest $request)
    {
        $this->authorize('permission-create');

        $permission = new Permission();
        $permission->name = $request->name;
        $permission->guard_name = 'web';

        if ($permission->save()) {
            return new PermissionResource($permission);
        }
    }
}
```

#### 3.9.3.4 Permission Management System

The permission system provides granular access control:

**Permission Structure:**
- Resource-based permissions (plants, users, categories)
- Action-based permissions (create, read, update, delete)
- Custom permissions for specific operations
- Permission inheritance through roles

### 3.9.4 Database Operations and ORM

#### 3.9.4.1 Eloquent ORM and Model Relationships

The application leverages Eloquent ORM for database operations:

**Model Relationships:**
```php
class Plant extends Model
{
    public function plantCategory()
    {
        return $this->belongsTo(PlantCategory::class, 'plant_category_id');
    }

    public function translations()
    {
        return $this->hasMany(PlantTranslation::class);
    }

    public function audioFiles()
    {
        return $this->hasMany(AudioFile::class);
    }
}
```

**Query Optimization:**
```php
public function index(Request $request)
{
    $query = Plant::with(['plantCategory', 'translations']);

    if ($request->has('search')) {
        $searchTerm = $request->input('search');
        $query->where(function ($q) use ($searchTerm) {
            $q->where('scientific_name', 'like', "%{$searchTerm}%")
                ->orWhere('family', 'like', "%{$searchTerm}%")
                ->orWhereHas('translations', function ($translationQuery) use ($searchTerm) {
                    $translationQuery->where('common_name', 'like', "%{$searchTerm}%");
                });
        });
    }

    $plants = $query->paginate(5);
    return PlantResource::collection($plants);
}
```

#### 3.9.4.2 Database Migrations and Seeding

The application uses Laravel's migration system for database management:

**Migration Features:**
- Version-controlled database schema
- Rollback capabilities
- Foreign key constraints
- Index optimization
- Data seeding for development

**Migration Example:**
```php
public function up(): void
{
    Schema::create('plants', function (Blueprint $table) {
        $table->id();
        $table->string('scientific_name')->unique();
        $table->unsignedBigInteger('plant_category_id')->nullable();
        $table->string('family')->nullable();
        $table->string('genus')->nullable();
        $table->string('species')->nullable();
        $table->json('image_urls')->nullable();
        $table->string('toxicity_level')->nullable();
        $table->timestamps();

        $table->foreign('plant_category_id')
            ->references('id')
            ->on('plant_categories')
            ->onDelete('set null');
    });
}
```

#### 3.9.4.3 Query Optimization and Performance

The application implements query optimization strategies:

**Optimization Techniques:**
- Eager loading to prevent N+1 queries
- Database indexing on frequently queried columns
- Query result caching
- Pagination for large datasets
- Selective field loading

#### 3.9.4.4 Transaction Management and Data Integrity

The application ensures data integrity through transaction management:

**Transaction Implementation:**
```php
public function store(StorePlantRequest $request)
{
    DB::beginTransaction();
    try {
        $plant = Plant::create($plantData);
        
        // Handle image uploads
        if ($request->hasFile('images')) {
            $imageUrls = [];
            foreach ($request->file('images') as $image) {
                $imagePath = $image->store('plants/images', 'public');
                $imageUrls[] = '/storage/' . $imagePath;
            }
            $plant->update(['image_urls' => json_encode($imageUrls)]);
        }

        // Handle translations
        foreach ($request->translations as $translation) {
            $plant->translations()->create($translation);
        }
        
        DB::commit();
        return new PlantResource($plant);
    } catch (\Exception $e) {
        DB::rollBack();
        return response()->json(['error' => $e->getMessage()], 500);
    }
}
```

### 3.9.5 File Management and Storage

#### 3.9.5.1 Laravel Storage and File Upload Handling

The application implements comprehensive file management:

**File Upload Features:**
- Multiple file upload support
- File validation and security checks
- Automatic file organization
- Storage disk abstraction
- File URL generation

**Implementation:**
```php
if ($request->hasFile('images')) {
    $imageUrls = [];
    foreach ($request->file('images') as $index => $image) {
        $extension = $image->getClientOriginalExtension();
        $filename = $plantFolderName . '_' . time() . '_' . $index . '.' . $extension;
        $imagePath = $image->storeAs("plants/{$plantFolderName}/images", $filename, 'public');
        $imageUrls[] = '/storage/' . $imagePath;
    }
    $plant->update(['image_urls' => json_encode($imageUrls)]);
}
```

#### 3.9.5.2 Image Processing and Optimization

The application includes image processing capabilities:

**Image Features:**
- Automatic image resizing
- Format conversion
- Quality optimization
- Thumbnail generation
- Metadata preservation

#### 3.9.5.3 Audio File Management and Processing

The application handles audio files for multilingual support:

**Audio Management:**
- Audio file upload and storage
- Format validation
- File size optimization
- Language-specific organization
- Streaming support

#### 3.9.5.4 Backup and Archival Strategies

The application implements data backup and archival:

**Backup Features:**
- Automated database backups
- File system backups
- Incremental backup strategies
- Cross-region replication
- Recovery testing procedures

The backend API development demonstrates a comprehensive implementation of modern Laravel development practices, with emphasis on security, performance, and scalability. The architecture supports the complex requirements of plant identification, multilingual content management, and user interaction while maintaining high standards of code quality and maintainability. 