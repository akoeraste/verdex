## 3.6 DATABASE DESIGN AND DATA MODELING

### 3.6.1 Database Schema Design and Normalization

The Verdex system employs a well-structured relational database design following third normal form (3NF) principles to ensure data integrity, eliminate redundancy, and optimize query performance. The database schema is designed to support multilingual content, user management, plant identification, and comprehensive administrative functions.

#### 3.6.1.1 Database Normalization Strategy

The database design follows normalization principles to minimize data redundancy and maintain referential integrity:

- **First Normal Form (1NF)**: All tables contain atomic values with no repeating groups
- **Second Normal Form (2NF)**: All non-key attributes are fully dependent on the primary key
- **Third Normal Form (3NF)**: No transitive dependencies exist between non-key attributes

#### 3.6.1.2 Core Database Tables

The system comprises 15 primary tables designed to support all functional requirements:

**User Management Tables:**
- `users` - Core user authentication and profile data
- `password_resets` - Password recovery functionality
- `sessions` - User session management

**Plant Management Tables:**
- `plants` - Core plant taxonomy and scientific data
- `plant_categories` - Plant classification categories
- `plant_translations` - Multilingual plant content
- `audio_files` - Plant name pronunciation audio files

**User Interaction Tables:**
- `favorites` - User plant favorites
- `feedback` - User feedback and ratings

**Administrative Tables:**
- `roles` - Role-based access control
- `permissions` - System permissions
- `model_has_roles` - Role assignments
- `model_has_permissions` - Permission assignments
- `activity_log` - System activity tracking

**System Tables:**
- `languages` - Supported language codes
- `jobs` - Background job queue
- `failed_jobs` - Failed job tracking
- `notifications` - System notifications

### 3.6.2 Entity-Relationship Modeling

#### 3.6.2.1 Core Entities and Attributes

**Users Entity:**
```
users {
  id: bigint (PK)
  username: varchar(255) unique
  email: varchar(255) unique
  password: varchar(255)
  temp_pass: varchar(255) nullable
  temp_pass_created_at: timestamp nullable
  language_preference: varchar(255) default('en')
  avatar: varchar(255) nullable
  email_verified_at: timestamp nullable
  remember_token: varchar(100) nullable
  created_at: timestamp
  updated_at: timestamp
}
```

**Plants Entity:**
```
plants {
  id: bigint (PK)
  scientific_name: varchar(255) unique
  plant_category_id: bigint (FK) nullable
  family: varchar(255) nullable
  genus: varchar(255) nullable
  species: varchar(255) nullable
  image_urls: json nullable
  toxicity_level: varchar(255) nullable
  created_at: timestamp
  updated_at: timestamp
}
```

**Plant Translations Entity:**
```
plant_translations {
  id: bigint (PK)
  plant_id: bigint (FK)
  language_code: varchar(8)
  common_name: varchar(255)
  description: text
  uses: text
  audio_url: varchar(255) nullable
  created_at: timestamp
  updated_at: timestamp
}
```

#### 3.6.2.2 Relationship Mapping and Cardinality

The database implements the following key relationships:

**One-to-Many Relationships:**
- User → Favorites (1:N)
- User → Feedback (1:N)
- Plant Category → Plants (1:N)
- Plant → Plant Translations (1:N)
- Plant → Audio Files (1:N)
- User → Activity Logs (1:N)

**Many-to-Many Relationships:**
- Users ↔ Roles (N:M via model_has_roles)
- Users ↔ Permissions (N:M via model_has_permissions)
- Roles ↔ Permissions (N:M via role_has_permissions)

**One-to-One Relationships:**
- User → Language Preference (1:1)

#### 3.6.2.3 Foreign Key Constraints and Integrity

The database enforces referential integrity through foreign key constraints:

```sql
-- Plant category relationship
ALTER TABLE plants 
ADD CONSTRAINT fk_plants_category 
FOREIGN KEY (plant_category_id) 
REFERENCES plant_categories(id) 
ON DELETE SET NULL;

-- Plant translations relationship
ALTER TABLE plant_translations 
ADD CONSTRAINT fk_translations_plant 
FOREIGN KEY (plant_id) 
REFERENCES plants(id) 
ON DELETE CASCADE;

-- User favorites relationship
ALTER TABLE favorites 
ADD CONSTRAINT fk_favorites_user 
FOREIGN KEY (user_id) 
REFERENCES users(id) 
ON DELETE CASCADE;

-- Feedback relationships
ALTER TABLE feedback 
ADD CONSTRAINT fk_feedback_user 
FOREIGN KEY (user_id) 
REFERENCES users(id) 
ON DELETE SET NULL;
```

### 3.6.3 Database Optimization and Indexing Strategy

#### 3.6.3.1 Primary Key Indexing

All tables utilize auto-incrementing primary keys with clustered indexes for optimal performance:

```sql
-- Primary key indexes (automatically created)
CREATE UNIQUE INDEX PRIMARY ON users(id);
CREATE UNIQUE INDEX PRIMARY ON plants(id);
CREATE UNIQUE INDEX PRIMARY ON plant_translations(id);
```

#### 3.6.3.2 Foreign Key Indexing

Foreign key columns are indexed to optimize join operations:

```sql
-- Foreign key indexes
CREATE INDEX idx_plants_category ON plants(plant_category_id);
CREATE INDEX idx_translations_plant ON plant_translations(plant_id);
CREATE INDEX idx_favorites_user ON favorites(user_id);
CREATE INDEX idx_favorites_plant ON favorites(plant_id);
CREATE INDEX idx_feedback_user ON feedback(user_id);
CREATE INDEX idx_feedback_plant ON feedback(plant_id);
```

#### 3.6.3.3 Unique Constraint Indexing

Unique constraints ensure data integrity and provide query optimization:

```sql
-- Unique constraints
CREATE UNIQUE INDEX idx_users_username ON users(username);
CREATE UNIQUE INDEX idx_users_email ON users(email);
CREATE UNIQUE INDEX idx_plants_scientific_name ON plants(scientific_name);
CREATE UNIQUE INDEX idx_translations_plant_lang ON plant_translations(plant_id, language_code);
CREATE UNIQUE INDEX idx_favorites_user_plant ON favorites(user_id, plant_id);
CREATE UNIQUE INDEX idx_audio_plant_lang ON audio_files(plant_id, language);
```

#### 3.6.3.4 Composite Indexing Strategy

Composite indexes are implemented for frequently queried column combinations:

```sql
-- Composite indexes for common query patterns
CREATE INDEX idx_plants_taxonomy ON plants(family, genus, species);
CREATE INDEX idx_translations_search ON plant_translations(language_code, common_name);
CREATE INDEX idx_feedback_status ON feedback(user_id, created_at);
```

### 3.6.4 Data Migration and Versioning Strategy

#### 3.6.4.1 Laravel Migration System

The system utilizes Laravel's migration system for database versioning and schema management:

**Migration Naming Convention:**
```
YYYY_MM_DD_HHMMSS_descriptive_migration_name.php
```

**Migration Structure:**
```php
public function up(): void
{
    Schema::create('table_name', function (Blueprint $table) {
        // Table definition
    });
}

public function down(): void
{
    Schema::dropIfExists('table_name');
}
```

#### 3.6.4.2 Incremental Migration Strategy

Migrations are designed to be incremental and non-destructive:

- **Additive Changes**: New columns and tables are added without removing existing data
- **Backward Compatibility**: Existing functionality remains intact during migrations
- **Rollback Capability**: All migrations include proper rollback methods

#### 3.6.4.3 Data Seeding Strategy

Database seeding ensures consistent initial data:

```php
// Language seeder
class LanguageSeeder extends Seeder
{
    public function run(): void
    {
        Language::create(['code' => 'en', 'name' => 'English']);
        Language::create(['code' => 'fr', 'name' => 'French']);
        Language::create(['code' => 'es', 'name' => 'Spanish']);
        Language::create(['code' => 'bn', 'name' => 'Bengali']);
    }
}
```

### 3.6.5 Backup and Recovery Procedures

#### 3.6.5.1 Automated Backup Strategy

The system implements automated backup procedures:

**Daily Backups:**
- Full database backup at 2:00 AM
- Incremental backups every 6 hours
- Backup retention for 30 days

**Backup Components:**
- Database schema and data
- Uploaded media files
- Configuration files
- Log files

#### 3.6.5.2 Recovery Procedures

**Point-in-Time Recovery:**
- Database can be restored to any point within 30 days
- Transaction log backups enable granular recovery
- Media files are versioned for selective restoration

**Disaster Recovery:**
- Cross-region backup replication
- Automated failover procedures
- Recovery time objective (RTO): 4 hours
- Recovery point objective (RPO): 1 hour

#### 3.6.5.3 Data Integrity Verification

**Backup Validation:**
- Automated backup integrity checks
- Test restoration procedures
- Data consistency verification
- Performance impact assessment

### 3.6.6 Local Database Design (Mobile Application)

#### 3.6.6.1 SQLite Database Schema

The mobile application implements a local SQLite database for offline functionality:

```sql
-- Local plants table
CREATE TABLE plants (
    id INTEGER PRIMARY KEY,
    scientific_name TEXT,
    name TEXT,
    description TEXT,
    family TEXT,
    category TEXT,
    genus TEXT,
    species TEXT,
    toxicity_level TEXT,
    uses TEXT,
    tags TEXT,
    image_url TEXT,
    created_at TEXT,
    updated_at TEXT,
    needs_sync INTEGER DEFAULT 0
);
```

#### 3.6.6.2 Synchronization Strategy

**Offline-First Architecture:**
- Local database serves as primary data source
- Synchronization occurs when connectivity is available
- Conflict resolution prioritizes server data
- Incremental sync reduces bandwidth usage

**Sync Indicators:**
- `needs_sync` flag identifies modified records
- Timestamp-based conflict detection
- User preference preservation during sync

### 3.6.7 Database Performance Monitoring

#### 3.6.7.1 Query Performance Analysis

**Performance Metrics:**
- Query execution time monitoring
- Slow query identification and optimization
- Index usage analysis
- Connection pool utilization

**Optimization Techniques:**
- Query result caching with Redis
- Database connection pooling
- Prepared statement usage
- Query plan analysis and optimization

#### 3.6.7.2 Scalability Considerations

**Horizontal Scaling:**
- Read replicas for query distribution
- Database sharding strategies
- Connection load balancing
- Caching layer implementation

**Vertical Scaling:**
- Resource allocation optimization
- Memory and CPU utilization monitoring
- Storage performance tuning
- Backup and maintenance window optimization

The database design provides a robust foundation for the Verdex system, ensuring data integrity, performance optimization, and scalability while supporting the complex requirements of multilingual plant identification and user management. 